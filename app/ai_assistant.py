from __future__ import annotations

"""
Property of Data-Blitz Inc.
Author: Paul Harvener

Intent parsing and response summarization utilities for assistant search.
"""

import json
import os
import re
from typing import Any

import httpx

from app.models import ProductResult, QueryIntent


class QueryInterpreter:
    # Args:
    #   None
    # Returns:
    #   None
    # Notes:
    #   Loads optional OpenAI credentials and model configuration from env vars.
    def __init__(self) -> None:
        self.api_key = os.getenv("OPENAI_API_KEY")
        self.model = os.getenv("OPENAI_MODEL", "gpt-5.2")

    # Args:
    #   message: str
    #     User prompt in natural language.
    # Returns:
    #   QueryIntent
    #     Structured search intent extracted via OpenAI or rule fallback.
    def interpret(self, message: str) -> QueryIntent:
        if self.api_key:
            try:
                return self._interpret_with_openai(message)
            except Exception:
                pass
        return self._interpret_with_rules(message)

    # Args:
    #   intent: QueryIntent
    #     Parsed search intent associated with product lookup.
    #   products: list[ProductResult]
    #     Ranked candidate products.
    #   mode: str
    #     Active catalog mode indicator ("elasticsearch" or fallback mode).
    # Returns:
    #   str
    #     Human-readable summary for the UI response panel.
    def summarize(self, intent: QueryIntent, products: list[ProductResult], mode: str) -> str:
        if not products:
            return (
                "I could not find matching products for that request. "
                "Try broader keywords or relax stock/price constraints."
            )

        best = products[0]
        return (
            f"Best match: {best.manufacturer_part_number} ({best.name}) by {best.manufacturer}. "
            f"It is ${best.unit_price:.2f} with {best.quantity_available} units available. "
            f"Selected from {len(products)} candidates in {mode} mode."
        )

    # Args:
    #   message: str
    #     Raw user input.
    # Returns:
    #   QueryIntent
    #     Deterministic parsed intent from keyword/pattern heuristics.
    # Notes:
    #   Used when OpenAI credentials are not configured or model calls fail.
    def _interpret_with_rules(self, message: str) -> QueryIntent:
        lowered = message.lower()

        in_stock_only = not any(phrase in lowered for phrase in ["out of stock", "backorder", "any availability"])
        limit = _extract_limit(lowered) or 8
        min_quantity = _extract_int_after_patterns(lowered, [r"at least (\d+)", r"minimum (\d+)"])
        max_unit_price = _extract_float_after_patterns(lowered, [r"under \$?(\d+(?:\.\d+)?)", r"max \$?(\d+(?:\.\d+)?)"])

        sort_preference = "relevance"
        if "cheapest" in lowered or "lowest price" in lowered:
            sort_preference = "price_low"
        elif "most stock" in lowered or "highest stock" in lowered:
            sort_preference = "stock_high"

        keywords = re.sub(r"\s+", " ", message).strip()

        return QueryIntent(
            keywords=keywords,
            limit=limit,
            in_stock_only=in_stock_only,
            min_quantity=min_quantity,
            max_unit_price=max_unit_price,
            sort_preference=sort_preference,
        )

    # Args:
    #   message: str
    #     Raw user input.
    # Returns:
    #   QueryIntent
    #     Structured intent generated by OpenAI Responses API JSON schema output.
    # Notes:
    #   Expects valid schema-compliant JSON from the model output text.
    def _interpret_with_openai(self, message: str) -> QueryIntent:
        schema = {
            "type": "object",
            "additionalProperties": False,
            "required": [
                "keywords",
                "limit",
                "in_stock_only",
                "min_quantity",
                "max_unit_price",
                "sort_preference",
            ],
            "properties": {
                "keywords": {"type": "string"},
                "limit": {"type": "integer", "minimum": 1, "maximum": 20},
                "in_stock_only": {"type": "boolean"},
                "min_quantity": {"type": ["integer", "null"], "minimum": 0},
                "max_unit_price": {"type": ["number", "null"], "exclusiveMinimum": 0},
                "sort_preference": {
                    "type": "string",
                    "enum": ["relevance", "price_low", "stock_high"],
                },
            },
        }

        payload = {
            "model": self.model,
            "input": [
                {
                    "role": "system",
                    "content": [
                        {
                            "type": "input_text",
                            "text": (
                                "Convert user requests into structured product search intent for an electronics catalog. "
                                "Output valid JSON only. Keep keywords concise but preserve critical constraints."
                            ),
                        }
                    ],
                },
                {
                    "role": "user",
                    "content": [{"type": "input_text", "text": message}],
                },
            ],
            "text": {
                "format": {
                    "type": "json_schema",
                    "name": "catalog_query_intent",
                    "strict": True,
                    "schema": schema,
                }
            },
            "max_output_tokens": 320,
        }

        with httpx.Client(timeout=15) as client:
            response = client.post(
                os.getenv("OPENAI_BASE_URL", "https://api.openai.com") + "/v1/responses",
                headers={"Authorization": f"Bearer {self.api_key}"},
                json=payload,
            )
            response.raise_for_status()
            body = response.json()

        parsed = json.loads(_extract_response_text(body))
        return QueryIntent(**parsed)


# Args:
#   text: str
#     Lowercased request text.
# Returns:
#   int | None
#     Extracted "top N" value constrained to 1..20, else None.
def _extract_limit(text: str) -> int | None:
    top_match = re.search(r"top (\d+)", text)
    if top_match:
        return max(1, min(int(top_match.group(1)), 20))
    return None


# Args:
#   text: str
#     Lowercased request text.
#   patterns: list[str]
#     Regex patterns where group(1) contains integer value.
# Returns:
#   int | None
#     First matching integer value or None.
def _extract_int_after_patterns(text: str, patterns: list[str]) -> int | None:
    for pattern in patterns:
        match = re.search(pattern, text)
        if match:
            return int(match.group(1))
    return None


# Args:
#   text: str
#     Lowercased request text.
#   patterns: list[str]
#     Regex patterns where group(1) contains numeric value.
# Returns:
#   float | None
#     First matching float value or None.
def _extract_float_after_patterns(text: str, patterns: list[str]) -> float | None:
    for pattern in patterns:
        match = re.search(pattern, text)
        if match:
            return float(match.group(1))
    return None


# Args:
#   body: dict[str, Any]
#     Raw JSON body returned by OpenAI Responses API.
# Returns:
#   str
#     Extracted text payload containing schema JSON.
# Raises:
#   ValueError
#     If no usable text content exists in response body.
def _extract_response_text(body: dict[str, Any]) -> str:
    if isinstance(body.get("output_text"), str) and body["output_text"].strip():
        return body["output_text"]

    output = body.get("output", [])
    for item in output:
        for content in item.get("content", []):
            text = content.get("text")
            if isinstance(text, str) and text.strip():
                return text

    raise ValueError("No usable text in OpenAI response")
